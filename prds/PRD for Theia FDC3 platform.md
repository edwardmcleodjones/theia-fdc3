# PRD for Theia platform

Requirements:

# Overview:

Use the open source Theia IDE as a base for creating an OpenFin/"Here" style workspace and browser container system (https://www.here.io/here-core).

It will support "apps" as widgets and web apps (via VS Code Webview API), as it is browser based.

## Comparison with OpenFin

There is a lot of overlap in capabilities between Theia and OpenFin, e.g. workspaces, layouts, app to app interop and communications, notifications, and an app store.

The main difference with Theia (as it is based on VS Code) is that it is document centric by default, i.e. built primarily as an IDE for working with text files.

OpenFin by contrast is context focused by default, where that context might be a client that all the apps within the workspace align to show the details for.

So the key challenge will be removing the document centric parts of Theia and aligning it to work with different ways of selecting contexts and broadcasting those across the apps within the workspace.

## FDC3 support

Additionally, while Theia has it's own communication channels for sharing events and data between apps, we want to add in support for FDC3 contexts.

To do that, we want to add in full support for the FDC3 "DesktopAgent" orchestration for app to app communication: https://fdc3.finos.org/docs/api/ref/desktopagent/

The apps we host within the platform will send and receive contexts and intents in FDC3 format to and from the DesktopAgent.

Theia's existing communication channels can be used for the underlying transport mechanism.

## Features

We want to support the following features:

### Workspaces

Instead of a workspace being a VS Code style folder on the file system, a workspace should instead be an isolated space with a specific overall context to work within, e.g. a client.

This can be representated as a top level tab (within the platform, not as a native browser tab), allowing the creation of multiple workspaces by adding new tabs.

Events within a workspace should be scoped within the workspace, e.g. if I select a client, only the apps within the workspace should respond to that selection, the other workspace tabs retain their own context.

### Layouts

We want to be able to layout the apps using Theia's built in layout controls. Most of the time, apps will appear in the middle pane, and need to be able to be split and rearranged within that pane.

The left hand pane will be for specific apps like a client picker that drive the apps in the middle pane.

There will also be a right hand pane for an AI chat, the existing Theia AI capabilities can be used for this.

### App to app interop and communications

FDC3 formatted messages can be broadcast / intents can be raised, and responded to by apps within a workspace.

Existing Theia communication channels can be used to transport the messages / events / data.

A top level FDC3 DesktopAgent will be hosted by the platform itself to orchestrate this.

We will want to be able to track the messages for debugging purposes using the existing Theia / VS Code style logging viewer in the bottom pane.

### Notifications

Apps will be able to raise notifications and respond to events triggered from a notification (e.g. button click) via the existing Theia notification mechanisms.

### App store

Apps will be packaged as VSIX format apps in the same way that VS Code extensions are.

Theia can connect to an Open VSX registry, e.g. https://open-vsx.org/

We will host the open source version of this registry.

https://github.com/eclipse/openvsx/wiki/Deploying-Open-VSX

The platform will then connect to that self hosted instance, and show the apps available.

---

Docs:

https://theia-ide.org/
https://theia-ide.org/docs/
https://github.com/eclipse-theia/theia
https://github.com/eclipse-theia/theia/tree/master/doc
https://theia-ide.org/docs/composing_applications/
https://theia-ide.org/docs/blueprint_documentation/
https://resources.here.io/docs/core/
https://fdc3.finos.org/docs/api/ref/desktopagent/
https://code.visualstudio.com/api/extension-guides/overview
https://github.com/github/spec-kit

---

# Theia FDC3 Platform PRD

Theia-Based FDC3 Workspace Platform

## Constitution

- **Open-Source Foundation:** Build on the Eclipse Theia IDE platform to leverage its modular, extensible architecture and VS Code compatibility. While we are working in a fork of the Theia IDE project, we will respect Theia’s design principles and avoid modifying core unless necessary, preferring to add or remove features via extensions: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=about%20Theia%20extension%20capabilities%20,VS%20Code%20extensions%20at%20runtime). This ensures we maintain upgradability and benefit from the community’s ongoing improvements.
- **Context-Driven Design:** Orient the platform around **business context** (e.g. client or project) rather than files. Unlike a traditional IDE, our product will not be document-centric. All design decisions should prioritize user workflow context (such as a selected client or case) as the primary organizing principle, ensuring that apps synchronize their content based on shared context rather than open files.
- **FDC3 Interoperability:** Adhere to FINOS FDC3 standards for cross-application communication. Our platform will include a **Desktop Agent** implementation of the FDC3 API, acting as the orchestrator for launching apps and routing messages: [fdc3.finos.org](https://fdc3.finos.org/docs/api/ref/DesktopAgent#:~:text=An%20FDC3%20Desktop%20Agent%20is,for%20applications%20in%20its%20domain). This commitment to open standards ensures any FDC3-compliant app can interoperate within the workspace. We will prioritize security and encapsulation in message passing (only apps within the authorized workspace context receive broadcasts or intents).
- **Modularity and Extensibility:** Design the platform as a composition of **Theia extensions**. Each major feature (workspace management, context sharing, notifications, etc.) will be implemented as a separate extension or plugin. This modular approach aligns with Theia’s architecture and allows selective enabling/disabling of features for different deployments. It also encourages third-party developers to contribute or create new “apps” (extensions) easily.
- **User Experience and Productivity:** Emphasize a clean, intuitive UI that feels like a modern workspace browser rather than an IDE. Default IDE features that are document specific (file explorer, text editor, etc.) will be hidden or removed if not relevant, reducing clutter. This should be straightforward using Theia's modular approach. The UI will introduce elements like top-level workspace tabs, an app launcher or dock, and context selectors to make multi-app workflows seamless. We prioritize short learning curve and consistency with paradigms users know from OpenFin/HERE containers.
- **Consistency and Compatibility:** Maintain compatibility with VS Code extension APIs as much as possible, so that existing VSIX-packaged apps can run with minimal changes. The platform will use the Open VSX registry for extension discovery: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=Extension%20sources). We aim to support installing and running VS Code extensions at runtime to extend functionality, but within the constraints of our context-focused environment. (Any deviations or unsupported VS Code API areas will be documented clearly.)
- **Quality, Security, and Maintainability:** All development will follow best practices for code quality (code reviews, testing) and ensure the platform remains secure (untrusted app content will be sandboxed via Theia’s webview isolation, and inter-app communication will be controlled). As an enterprise-focused platform, we will keep in mind future requirements like single sign-on, role-based access, and data privacy – even if not implemented initially, the architecture should not preclude adding these later. We acknowledge that features like multi-window support, external desktop agent bridging, and enterprise security controls are valuable, but will introduce them in later phases once the core is stable.

## Spec

**Product Vision:** The proposed platform is a **browser-based and Electron-based workspace container** that allows users to run multiple business applications (as pluggable “apps”) side by side, share context between them, and organize their workflow by **workspaces**. It draws inspiration from OpenFin/HERE Enterprise Browser, but is built on open-source technology (Theia IDE). The goal is to provide the interoperability and unified experience of a financial desktop container while leveraging the rich ecosystem of VS Code extensions for app development.

### Key Use Cases and Features

- **Multiple Contextual Workspaces:** Users can create and manage multiple workspaces, each tied to a distinct context (for example, a specific client or project). Within a workspace, any context-changing action (like selecting a client) will broadcast to all apps in that workspace only, keeping other workspaces independent. Workspaces are presented as top-level tabs within the application (not separate browser tabs or windows), allowing quick switching. This enables a user to handle different clients or tasks in parallel without context collisions. _Why:_ In financial or enterprise workflows, users often juggle multiple clients/cases – separating them prevents confusion and fosters focus.
- **Flexible App Layouts:** Within each workspace, the user can arrange app windows (panels) flexibly in the central area. They can tile apps side-by-side, stack them in tabs, or split the view using Theia’s docking layout controls. There will be dedicated regions: an app launcher on the far left, a left sidebar for context/navigation apps (e.g. a client selector panel), a main content area for core apps, a right sidebar for the AI assistant and notifications center, and a bottom bar for logs and similar output. The layout should be persistent per workspace (with ability to save and restore layouts automatically when reopening a context). _Why:_ Users need to see multiple information sources simultaneously (e.g., client info app next to analytics app). Providing a flexible layout boosts productivity and mirrors familiar IDE or container layouts. We leverage Theia’s existing split-panel capabilities to implement this.
- **Context Sharing and FDC3 Interop:** The platform will include a global **DesktopAgent** to manage inter-app communication via the FDC3 standard. Apps can broadcast data (contexts) or raise intents (requests for action) that other apps in the same workspace can listen for and handle. For example, if an app broadcasting a `ClientContext` is active and the user selects a client “ACME Corp”, other apps in that workspace listening for `ClientContext` updates will receive that data and update themselves accordingly. If an app raises an intent like `ViewChart` for a particular stock, another app in the workspace can handle it (if it registered an intent listener for `ViewChart`). We will utilize Theia’s internal messaging mechanisms to route these events under the hood, but from the app developer’s perspective, they simply use the FDC3 API (`fdc3.broadcast`, `fdc3.raiseIntent`, etc.). The DesktopAgent ensures scope: context broadcasts or intents are delivered only to apps within the active workspace context (preventing bleed-over to other workspace tabs). _Why:_ This capability is analogous to OpenFin’s Interop and is core to a unified platform – it eliminates copy-paste and manual synchronization by linking apps together through shared context: [here.io](https://www.here.io/here-core#:~:text=Interop%20and%20FDC3%20APIs). Adopting the FDC3 standard means our container can integrate with any other FDC3-compliant apps or services in the future, reducing vendor lock-in for our users.
- **App Launching and Discovery (App Store):** Users can discover, install, and launch new apps through an integrated App Store interface. This will be based on the Open VSX extension registry. The platform will connect to a **self-hosted Open VSX registry** (an open-source marketplace for VS Code extensions) to fetch a list of available apps (VSIX packages): [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=Extension%20sources). Within the UI, a familiar Extensions view (rebranded as “App Store”) will allow searching or browsing apps by category. Installation of an app will make it immediately available in the platform. Launching apps: after installation, an app can be launched into the current workspace (for example, by clicking “Open” or via a dock menu if provided). We will repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar – a shortcut bar where frequently used apps or user-chosen apps can be pinned for one-click launching, similar to a taskbar. _Why:_ A built-in app store lowers the barrier to extending the platform and allows non-technical users to add capabilities easily. Using the VSIX format means developers can package apps in a known format and even reuse many VS Code extensions. A quick launcher (dock) improves UX by not requiring users to navigate menus to open apps they use often.
- **Notifications Center:** Applications within the workspace can raise notifications through the platform. We will use Theia’s notification UI (which typically shows a toast or message prompt) to display these. Notifications can include rich content and interactive elements (e.g., buttons). For example, a trading alert app might raise a notification “Price threshold reached for STOCK ABC” with options to “View Details” or “Snooze”. The platform will route notification click events back to the originating app or a designated handler via the FDC3 intent mechanism or direct callback. We will implement a **notification history view** (similar to the VS Code notification center or OpenFin’s Notification Center: [here.io](https://www.here.io/here-core#:~:text=Notification%20Center)) where users can see past notifications, group or filter them. This will need to have a toggle for all notifications, and just ones relevent to the current workspace.. _Why:_ Notifications are crucial in a multi-app environment to alert users of important events without requiring every app to be visible at all times. By centralizing them, we ensure users don’t miss critical updates. Using Theia’s existing mechanisms lets us implement this feature quickly and consistently.
- **Integrated AI Assistant Panel:** On the right sidebar of each workspace, users will have access to an AI chat assistant. We plan to leverage Theia’s built-in AI capabilities (Theia recently introduced an AI assistant integration: [theia-ide.org](https://theia-ide.org/docs/user_install_vscode_extensions/#:~:text=,12)) and adapt them to our context. This “AI Chat” panel can answer user queries, help with tasks like finding information across apps (akin to a super search), or even serve as a chatbot that interacts with the user’s current context. For instance, if the current workspace context is a client, the AI could be prompted with that context to answer questions specific to that client’s data (if such data is accessible). Initially, this AI assistant might rely on generic capabilities (like CodeGPT or an OpenAI integration included in Theia), but we will integrate it such that it’s easily accessible (opened by default in the right pane) and context-aware in the future. _Why:_ Many modern platforms include AI features to boost productivity. In our use case, an AI assistant can help summarize information from multiple apps or perform actions via intents upon user request, acting as a smart helper. Including it from the start (even if basic) sets the stage for advanced capabilities later (like natural language commands to navigate the workspace).
- **Logging and Debugging Tools:** To aid developers (and advanced users) in understanding the inter-app communication, the platform will include a logging view for FDC3 events and other app communications. We will repurpose or extend the existing Theia Output or Console panel to create an “Interop Log”. This log will record context broadcasts, intent raises, and resolution results in real-time, scoped by workspace. For example, if an app broadcasts a client context, an entry like “\[Workspace Alpha\] Broadcast ClientContext { clientId: 123 } by App X” would appear. Similarly, intents and their target resolution (which app handled it) would be logged. We may allow filtering this log by app or message type. _Why:_ In a complex app ecosystem, debugging who sent what context or why an intent didn’t trigger can be difficult. A built-in log viewer helps developers building apps on the platform to troubleshoot integration issues. It can also help with auditing and support, giving insight into the dynamic behavior of the workspace.

### Assumptions and Constraints

- **Initial Scope vs Future Enhancements:** Some features will **not** be part of the initial release but are noted for future consideration. For example, advanced **App Directory** functionality (a centralized directory of all available apps with their metadata and intent support) is something FDC3 supports: [fdc3.finos.org](https://fdc3.finos.org/docs/api/ref/DesktopAgent#:~:text=A%20Desktop%20Agent%20can%20be,and%20implementation%20requirements%20are%20proprietary), but initially we may rely on the Open VSX registry and simple metadata. Another future item is **FDC3 Desktop Agent bridging** (connecting our DesktopAgent with other containers on the same desktop) – not in scope now. Also, true multi-window support (e.g., dragging an app out into a separate native window or multi-monitor support) is deferred; initially all apps live inside the single container window with tabs. We want to validate the core concept in one window first. These decisions keep the project focused, but we are mindful that enterprise users might request them later.
- **No Traditional IDE Functions:** Since our platform repurposes Theia from a coding IDE to a business app container, we assume features like text editing, a file explorer, or debugger are **out of scope**. We will strip out or disable these by default. We will keep the integrated terminal, and "Extensions" panel though. The user is not expected to edit source code or manage a file system in this product. Instead, the left sidebar will host domain-specific navigation (like client lists or menus provided by apps), not a tree of files. This assumption simplifies the UI and avoids user confusion. (One caveat: we might retain _some_ generic utilities like a browser-like Developer Tools access for troubleshooting webview apps, but only for developers mode.)
- **Platform Compatibility:** The product must run on both modern web browsers and as an installed desktop application (Electron-based) on Windows (and ideally Mac/Linux for completeness). We assume the environment will have at least Chrome/Chromium engine (Electron uses Chromium, and for browser we’ll target Chrome/Edge for best support). Theia’s web-first design means almost everything is web tech, which we embrace. We also assume moderate hardware capabilities on user machines (Theia and Electron are not extremely lightweight, but acceptable for enterprise desktops).
- **Security Considerations:** We assume apps are generally trusted within the enterprise (since they will be installed via our controlled app store). However, we will still sandbox web content delivered via URL using iframes. Fully trusted apps can be embedded directly as widgets without requiring sandboxing. The VS Code webview API already provides an isolated iframe for extensions’ web content with only allowed messaging back to extension code. We will enforce content security policies to prevent malicious behavior. Also, since the platform may handle sensitive financial data, we will ensure that context data broadcasting is kept in-memory and not logged or sent externally (unless an extension does so on its own). Any future multi-tenant or cloud features will need authentication and encryption, but for now we assume a single-user local environment without login (the user is already authenticated to their machine or network).
- **Performance Constraints:** Running multiple apps inside one container means performance needs attention. We expect users might have 5-10 apps open per workspace, and maybe a couple of workspaces active. Theia’s architecture runs all VS Code extensions in a separate process (the plugin host) and heavy-lifting on a backend process. We assume this will handle our use case, but we will monitor memory and CPU usage. If needed, we might put certain apps to sleep when not in use or unload entire workspaces from memory if a user hasn’t looked at one in a while (as a future optimization). For now, performance should be acceptable given typical VS Code can handle many extensions simultaneously.
- **Unknowns / Open Questions:** Throughout development, a few questions need clarification:

  - _FDC3 Version_: We assume FDC3 2.0+ (latest 2.2) for DesktopAgent API. This gives us the channels concept which we can use for workspace scoping. We should confirm if any backward compatibility with FDC3 1.2 is needed.
    **Answer:** We will only support FDC3 2.0+.
  - _Context Data Models_: What context types and intent names will our target apps use? We might define custom context types (e.g., `ClientContext` with clientId, name, etc.) for our domain. This requires coordination with app developers or an app directory schema later. **Answer:** We will be using custom context and intents at a later date, but initially, only standard FDC3 ones are required to be supported.
  - _App Directory Integration_: In the future, do we plan to integrate a formal FDC3 App Directory service for app discovery and metadata (beyond the Open VSX registry)? This could enhance features like `findIntent` by looking up which app can handle an intent. For now, we’ll implement a simple in-memory directory or use a manifest in each extension.
    **Answer:** For now, we’ll use a manifest in each extension.
  - _App Launcher UI_: We propose a dock for launching installed apps; we should confirm if this is desired in MVP or if using Theia’s Command Palette / menu is sufficient initially. A slick app launcher will improve UX but could be added later.
    **Answer:** We will repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar
  - _Layout Persistence_: Should we implement saving and restoring of workspace layouts (positions and open apps) across sessions? We assume yes for user convenience, but it adds complexity (especially since we aren’t using file-workspaces to auto-save state). Possibly we store layout in local storage or a settings file keyed by workspace context. This needs confirmation.
    **Answer:** Yes, just persist to local storage initially.
  - _Branding and Naming_: We refer to the product as “Theia FDC3 Platform” here, but a proper product name and branding (icons, logos) will be needed. This is a minor point but part of polish – presumably will be decided later in the project. **Answer:** Just refer to it as "Theia FDC3" for now.

## Plan

**Tech Stack Overview:** We will use **TypeScript** for all development (client and server), as Theia is built in TypeScript. The runtime environment is Node.js (for Theia backend) and a browser/Electron (for front-end). We will create two build targets: a **web application** (Theia backend served via Node, front-end in browser) and a **desktop application** using **Electron** (packaged with electron-builder [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application) for Windows, Mac, Linux). This dual deployment strategy ensures users can either access the platform via a URL or install it as a native-like app. We’ll follow Theia’s standard blueprint structure which already separates an Electron build and a browser build in the project.

**Architecture and Components:**

- **Eclipse Theia Framework:** The core of our application. We will start from Theia IDE (formerly Blueprint) (the example product) as a template. Theia provides the shell (window management, menus, docking areas) and services (commands, menus, keybindings, preference storage, etc.). Importantly, Theia’s extension model will allow us to add our custom functionality. We plan to **remove certain core extensions** from the default Theia assembly (e.g., file-system navigator, text editor, git, etc.) to declutter the UI.
  Conversely, we will **add custom extensions** to implement new features (workspace context management, FDC3, etc.). Theia’s flexibility means we can adapt the feature set with almost no limits: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20is%20based,to%20modify%20which%20VS%20Code), which suits our project.
- **Custom Theia Extensions:** We anticipate developing several in-house extensions (each likely as its own npm package inside a monorepo or as part of the Theia application). Key extensions include:
  - **Workspace Manager Extension:** Responsible for managing workspace contexts and the top-level “workspace tabs” UI. This extension will provide a UI element (a tab bar at the top and a custom panel) to create, switch, rename, and close workspaces. It will maintain an internal registry of current workspaces, each with an identifier and context data. It will intercept Theia’s usual concept of “workspace” – possibly by operating in _multi-root workspace mode_ or by tricking Theia into treating each context as a separate workspace without a folder. We might use Theia’s widget APIs to implement a tabbed container that shows/hides sets of widgets belonging to each workspace. Another responsibility of this extension is scoping broadcasts: it will likely instantiate or configure the FDC3 DesktopAgent on a per-workspace basis (e.g., one channel per workspace).
  - **Context & FDC3 Extension:** This is the core of inter-app communication. It will implement the FDC3 `DesktopAgent` interface. Likely, we will expose `window.fdc3` to the front-end environment so that any app (especially those running as webviews) can call it. In an Electron environment, we can inject a preload script to set up `window.fdc3`. In a pure browser environment, since all apps are within the Theia front-end, we can attach `fdc3` to the global window of the Theia iframe or use Theia’s command system to simulate it. Under the hood, this extension will manage:
    - A **message bus**: We will use Theia’s `EventEmitter` pattern: [theia-ide.org](https://theia-ide.org/docs/events/#:~:text=private%20onLogLevelChangedEmitter%20%3D%20new%20Emitter) or the JSON-RPC communication channel between frontend and backend to propagate events. For example, when an app calls `fdc3.broadcast(context)`, our implementation will fire an event to all listeners in the same workspace. Because Theia runs extensions in a separate process, we might keep the DesktopAgent mainly in the frontend (so it can directly notify other webview iframes or extensions) and use the backend only if cross-process communication is needed.
    - **Context Channels:** We will leverage FDC3’s channel concept. Upon workspace creation, we can create a dedicated channel (with a unique ID, e.g., “workspace-XYZ-channel”). When apps launch in that workspace, our DesktopAgent will automatically join them to that channel (this could be done implicitly by our container, even if the app isn’t aware). Thus, a broadcast will effectively be contained to that channel/workspace. We’ll implement `getOrCreateChannel`, `joinUserChannel`, etc., but we might abstract this so that from the user perspective they don’t manually join channels – the platform does it for them based on active workspace.
    - **Intent Resolution:** We’ll maintain a simple registry of intent handlers. For each app that wants to handle an intent, we’ll provide an API (like `fdc3.addIntentListener(intentName, handler)`) which our DesktopAgent extension will register. When some app raises an intent, the DesktopAgent will look up the appropriate handler (in the same workspace) and invoke it. If multiple apps can handle, we may need an intent resolution UI (like “Which app do you want to handle this?”). Initially, we can assume one handler per intent (to avoid UI complexity), or choose the first registered. This is an area for expansion (maybe a quick palette if multiple choices).
    - **App Directory for Intents (Minimal):** In absence of a full App Directory service right now, we will use the extension manifests to identify what intents each app can handle, in order to implement `findIntent` or `raiseIntentForContext` properly. For MVP, this could be hard-coded or using each extension’s package.json `fdc3` field if provided.
    - **Logging:** This extension will also hook into all context and intent events and push log entries to the Logging UI (likely by writing to a dedicated OutputChannel in Theia). It could also expose a simple logger interface for apps to log custom events if needed.
  - **App Launch/Dock Extension:** This will manage how apps are launched in a workspace. We will repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar. We can augment that to allow “opening” an extension’s contribution. For example, an extension (app) that contributes a widget or webview panel can have a command to open that panel. Our App Launch extension could read all installed extensions that are flagged as “workspace apps” and list them for the user. Clicking an app in the list would execute its “open” command to create a new panel in the current workspace. This extension also ties into the App Store: after installing a new app, it should appear in the launcher list..
  - **Custom UI Extensions:** We will create some small extensions for specific UI elements:
    - _Client Picker Extension (Context Selector):_ A sample implementation of a context provider app that sits in the left sidebar. This extension could provide a tree or list of clients/projects (fetched from some API or a sample data source). When a user selects an item, the extension broadcasts an FDC3 context (e.g., `ClientContext` with the chosen client’s details) via the DesktopAgent. This will drive other apps to update. While this is technically an app, we might include it as a built-in example to demonstrate context setting. It will register itself as a left-panel widget.
    - _AI Assistant Extension:_ If Theia’s AI assistant is available as a Theia extension, we will include that. If not, we’ll create an extension that provides a chat UI panel on the right. This panel might call an external AI service (OpenAI, etc.) or use Theia’s AI backend if configured. We’ll keep it decoupled so the AI service URL or key can be configured. The extension could listen for the current context (so if a user is asking a question, it can include the current workspace’s context data in the prompt, within security allowances).
    - _Theming/Branding Extension:_ While not core to functionality, we may include a small extension or config changes for custom branding (name, logos, maybe a custom welcome screen). This ensures the product feels cohesive and not just a generic IDE. This might involve overriding Theia’s About dialog and logos as per Theia customization guidelines: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=You%20can%20also%20add%20your,the%20installer%20can%20be%20customized).
  - **Notifications Extension:** We may not need a separate extension if Theia’s built-in `MessageService` or notification system suffices. But we might extend it to support richer notifications (with multiple action buttons or form inputs in notifications, similar to HERE’s advanced notifications: [here.io](https://www.here.io/here-core#:~:text=Notification%20Center)). If needed, this extension would provide an API like `showNotification(title, message, actions, context)` that apps can call (possibly via the DesktopAgent as well, or a separate import if they’re Theia extensions). Under the hood it could wrap Theia’s notification UI but also tie into FDC3 intents (e.g., if a notification’s button corresponds to an intent like “OpenTradeTicket”, clicking it triggers that intent).
- **Open VSX Registry (App Store backend):** For the MVP we will implement this as just a static JSON file that can be read in. Eventually, post MVP, We will set up a private instance of Eclipse OpenVSX. This is a separate piece (not part of Theia code) that we will host on a server accessible to the app. The OpenVSX deployment requires a database and some storage; we’ll follow Eclipse’s guide: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=Extension%20sources) to deploy it. The plan is to have full control over what apps/extensions are available – initially, we might populate it with only our known good apps. The Theia front-end can be configured (via `package.json` or an ENV variable) to use our registry endpoint instead of the default. This way, when the user opens the App Store view, it queries our registry. We also have the option to bundle some extensions pre-installed (built-ins) if certain apps are mandatory for all users.
- **Data Storage:** For the most part, the platform doesn’t need a central database – it’s a container. However, we will use Theia’s built-in storage for user preferences and state. Theia typically stores settings in JSON and can also retain UI layout between sessions. We will utilize these mechanisms to remember things like last open workspace or panel sizes. For any additional data (like saved workspace definitions, or user’s list of favorite apps for the dock), we can either use Theia’s preferences API or simply store in local storage (browser) / a config file on desktop. Given this is a client-side heavy app, no significant server component (besides the OpenVSX service) is planned initially.
- **Third-Party Libraries:** We will use FINOS FDC3 TypeScript definitions to ensure compliance (if available, e.g. `@finos/fdc3` npm package for types). We might also incorporate a message routing library if needed, but likely Theia’s own event emitters suffice. For the AI extension, integration with an external API (OpenAI, etc.) will be done carefully (maybe using Theia AI extension or a direct call with fetch in the extension). We need to be mindful of any licensing – Theia is EPL/Apache licensed, our code will follow compatible licensing (likely Apache 2.0 or similar).
- **Deployment and Build Process:** We plan to keep the build process aligned with Theia’s recommended approach:
  - Use **Yarn** workspaces and Lerna (Theia’s monorepo uses Lerna) to manage extensions and the overall application.
  - For the Electron app: use `yarn electron build` to produce installers for each OS: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application). We’ll set up signing for Windows/macOS as needed (likely later, for distribution).
  - For the browser version: we can run Theia backend with `yarn start` (or a PM2 process in production). Optionally, containerize it with Docker for easy deployment on a server.
  - Continuous Integration: We’ll have CI scripts to build both versions and possibly publish the web version Docker image and the Electron artifacts.
  - We will also deploy our OpenVSX registry as a separate service (perhaps Dockerized as well). That requires periodic maintenance (to publish new app entries). In development, we might skip it and allow installing from the public OpenVSX, but production will use the private one.
- **Testing Strategy:** The plan will include a thorough testing approach: For the MVP we will keep tests minimal and lightweight, and rely on Theia's existing test suite, extending it where it makes sense without adding new dependencies. In future, we will consider the following:
  - **Unit Tests:** for the logic of context handling, intent routing, etc., using a framework like Mocha or Jest in the Theia environment.
  - **Integration Tests:** possibly using Theia’s built-in test support or Spectron (for Electron) to simulate user interactions: e.g., open two apps, broadcast a context, verify the other app received it.
  - **Manual Testing:** since UI/UX is crucial, we’ll have a period of manual testing to check that the workspace isolation feels correct, apps update as expected, and the UI remains responsive with multiple apps.
  - We also want to test both in Electron and pure browser to catch any differences (like `window.fdc3` injection might differ).

* **Future Architecture Considerations:** As the platform grows, we should keep in mind:
  - Possibly splitting out the DesktopAgent to a shared service if multiple windows are needed (e.g., an external process that all windows connect to, akin to OpenFin’s core).
  - Scaling the OpenVSX or moving to a more specialized app directory if needed for performance or richer metadata.
  - Adding a backend component for things like user login or data caching if we integrate with external data sources (for now, each app extension could directly fetch data from APIs, but a unified backend could mediate if needed later).

In summary, the plan is to **utilize Theia’s extension-based architecture** to transform the IDE into a context-driven workspace container. We carefully choose tech that aligns with Theia (TypeScript, VS Code extension format, Electron) to minimize risk. Each needed feature is an extension or configuration change, which keeps the design clean. The architecture favors an in-process event driven approach (since everything runs within the Theia container process or plugin process) for speed. We will document our extensions well so that others can build on this platform, following the open-source spirit.

## Tasks

Below is a structured list of development tasks derived from the plan. These tasks are ordered in a logical implementation sequence:

1.  [x] **Project Setup [Complete]** Initialize the custom Theia-based application project.
    - Fork or scaffold from Theia Blueprint. Configure the package.json/workspace to prepare for custom extensions (use the Theia Yo generator for a starting extension if needed).
    - Set up the build scripts for both browser and Electron targets. Verify that you can run a stock Theia application in both modes.
    - **Output:** A baseline application that launches Theia with default features (we will remove/add features in subsequent steps).
2.  **Remove/Disable Unwanted Features:** Strip out the default Theia IDE functionality that is out-of-scope.
    - In the application assembly (package.json), remove Theia core extensions related to file system, editor, SCM, debug, etc. (e.g., `@theia/navigator`, `@theia/editor`, and others).
    - Adjust the frontend application configuration to hide any remaining traces (for example, if the menu still shows “File -> Open”, override or remove it).
    - Use this article as a basis for understanding how to customize Theia: https://dzone.com/articles/theia-deep-dive-mastering-customization
    - Test launch to ensure the UI is now minimal – ideally just an empty shell with maybe an empty explorer area and top menu. It should not prompt for opening a workspace folder. _(If Theia complains about no workspace, implement a workaround such as opening a temporary in-memory workspace or patching the workflow.)_
    - **Output:** A “clean” container UI with only barebones elements visible.
3.  **Logging View for Interop:** Implement the logging of messages and events.

    - Use Theia’s OutputChannel service to create a new channel (e.g., “FDC3 Log”). Whenever DesktopAgent handles a broadcast or intent, write a line to this channel. Include timestamp, workspace, type of event, and maybe the payload summary.
    - Add a command or automatic opening of an Output panel for this channel. Possibly, create a custom widget that formats entries nicely (optional enhancement).
    - Test by performing a few context broadcasts/intents and seeing the log output in the UI.
    - **Output:** A visible log console that updates with FDC3 and context events, assisting in debugging app interactions.

4.  **FDC3 DesktopAgent Extension:** Implement the core FDC3 interoperability features.
    - Define the DesktopAgent API surface (as per FDC3 spec) in TypeScript. Create a class `DesktopAgentImpl` with methods: `broadcast(context)`, `raiseIntent(intent, context, target)`, `addContextListener`, `addIntentListener`, `findIntent(s)`, `getOrCreateChannel`, etc. For now, some methods can be stubs or simplified (e.g., `findIntent` can just search our local registry of listeners). The main methods we're initially interested in are around broadcasts and channels.
    - **Context broadcasting:** Implement `broadcast` to publish the context to all listeners in the same workspace. You can use an event emitter keyed by workspace. For example, an object `workspaceContextBus[workspaceId]` that is an EventEmitter where all context listeners have subscribed. When broadcast is called, emit the event to that bus.
    - **Context listening:** Implement `addContextListener(contextType, handler)`. When an app calls this (through the global fdc3 or via extension API), register the handler to the workspace’s context bus. If a specific `contextType` is provided, the handler should filter events (the extension can do filtering internally: call handler only if `event.type` matches or is subtype).
    - **Intents:** Implement `addIntentListener(intent, handler)` to register an intent consumer (probably store in a map like `workspaceIntents[workspaceId][intent] = handler` or a list of handlers). Implement `raiseIntent(intent, context, target)` to find a handler in the workspace. If `target` (specific app identity) is given, route to that app’s handler only; if not, and if exactly one handler exists, invoke it. If multiple handlers exist and no target, this is where we might need to decide (for now, perhaps invoke the first or show a console warning). The handler invocation could be done via calling the extension’s code directly (if the handler is a callback in the same process) or via command if the target app needs to be brought to front.
    - **Channels:** Implement basic channel management. Create a `Channel` class that has an ID and maybe its own context listener list. We can simplify by equating “workspace = channel” for MVP purposes. So `getOrCreateChannel(id)` either returns an existing workspace channel or creates a new one (if we want to allow custom channels separate from workspaces, we could, but not necessary initially). Ensure `joinUserChannel(channelId)` essentially means “move this app to that workspace context” – however, since our apps won’t roam between workspaces (they belong to the one where opened), this might not be heavily used. We could leave channel APIs as no-ops or just map to workspace join.
    - **Expose `fdc3` to apps:** This is crucial. For any VS Code extension (app) that runs in the Theia plugin host, we need to expose our DesktopAgent through the VS Code API somehow. Perhaps a globally accessible object. E.g., use Theia’s `window` injection. In Electron, inject `window.fdc3 = DesktopAgentImpl` for webviews. For regular non-webview extensions (those running in the backend plugin process), we can make our DesktopAgent available via RPC calls or a custom VS Code extension API (maybe as part of the extension API in Theia).
    - **Testing this extension:** Create a dummy extension or use the ClientPicker (once implemented in the next task) to test broadcasting contexts. Also prepare a second dummy app that calls `fdc3.addContextListener(null, handler)` and log or alert when it receives something, to verify it works.
    - **Output:** The platform now has a working (even if basic) FDC3 DesktopAgent. Apps can call `fdc3.broadcast` or `fdc3.raiseIntent` and the messages are routed to the appropriate listeners in the same workspace. This is the core enabling technology of our platform.
5.  **Context Selection (Client Picker) Extension:** Develop a sample context provider to drive context changes.
    - Create a **ClientPickerWidget** (or similar) as a left panel contribution. This can simply list some dummy context options to start with (e.g., a hardcoded list of client names, using the top 10 companies on the UK stock market).
    - When the user selects an item, this extension should broadcast an FDC3 context object for that client (e.g., `{ type: 'fdc3.client', name: 'NatWest', id: { clientId: 'natwest' } }` ). Use the DesktopAgent API (implemented in the previous Task: "3. FDC3 DesktopAgent Extension").
    - Ensure this broadcast is tagged with the current workspace’s context/channel so that only apps in the same workspace respond.
    - Also, when a new workspace is created, open an instance of the ClientPickerWidget in the left pane automatically (so each workspace has its own independent client selector). This might require the workspace manager to instantiate a new widget for each workspace.
    - **Output:** Output: A functional left sidebar in each workspace where selecting an entry triggers a context broadcast (even if other apps are not yet listening, we should see the action, by logging it so we can see it in Theia's "OutputChannel" log output widget - see Task: "Logging View for Interop").
6.  **Implement Workspace Manager Extension:** Create the extension for managing multiple workspaces (contexts).
    - Design the UI for workspace tabs: This will be a new widget above the main content area. Theia's existing `Dynamic Toolbar` should be duplicated as `WorkspaceTabsWidget` and the copied code converted to display a tab for each open workspace and a “+” button to create new one. See: https://theia-ide.org/docs/toolbar/ and https://theia-ide.org/docs/user_toolbar/
    - Handle workspace creation: When user clicks “+” or invokes a command, create a new workspace context (generate an ID, default name). Prompt for a workspace /context name (e.g., client name) using the built-in Theia / VS Code style picker dialog.
    - Handle switching: When a tab is clicked, the extension should hide all widgets belonging to the previous workspace and show widgets for the selected one. (This implies any app opened needs to be associated with a workspace ID. We may need to extend Theia’s Widget class to tag them with workspace context, or maintain a mapping in this extension.) This should initially work using the existing tab functionality that exists in Theia for tabbed documents.
    - Handle closing: On tab close, dispose all widgets of that workspace (closing all apps in it) and remove context listeners related to it.
    - Persist the list of workspaces and their state: To restore on restart, store open workspace names and which apps were open and how they were laid out using the Layouts. This can be presisted to local storage for now, or using the Theia user preferences if that's more appropriate/straightforward.
    - Also create a workspace widget that can show in the left hand sidebar panel (left panel contribution), that lists all the workspaces, and allows them to be renamed, reordered, closed, etc. This be be based on the existing file list widget, and work in a similar way (list of workspaces instead of files, allow renaming, reordering, closing, etc).
    - **Output:** Visible workspace tabs in the UI and the ability to create, switch, and close workspaces (as empty contexts). No context data yet, just the structural aspect.
7.  **Notifications Integration:** Enable apps to send notifications and handle user interaction from them.
    - Using Theia’s built-in notification (which is usually accessible via `MessageService` or similar with methods like `notify` or `showMessage`), write a small wrapper that apps can call. For VS Code-compatible behavior, we might surface it as part of the DesktopAgent (though FDC3 itself doesn’t define notifications, we can treat them as a special case). Alternatively, provide a global function or command like `app.notify(title, options)`.
    - Ensure that notifications triggered by one app can carry some context such that if the user clicks an action, we know which app or handler to invoke. One design: use FDC3 intents for actions. E.g., a notification “Review order” with a “OpenOrder” button could internally call `raiseIntent("OpenOrder", orderContext)` if clicked.
    - Possibly extend Theia’s Notification widget to include more actions or fields if needed (Theia might support basic actions on notifications out of the box).
    - Test by making a sample app or using an extension API call to raise a notification with a couple of action buttons. Verify the user sees it and that clicking triggers the expected behavior (e.g., logs an entry or opens something).
    - Also implement a "Notifications Center" widget similar to in VS Code (https://code.visualstudio.com/docs/getstarted/userinterface#_reduce-notifications-with-do-not-disturb-mode), where all the notifications can be seen in a list. This should live in the right hand panel by default.
    - **Output:** Apps have the ability to raise user notifications. The user sees these in a consistent manner (likely at the bottom-right or top depending on Theia’s UX). Interactive elements in notifications are connected back to app logic via intents or callbacks. The user can also see all of their notifications in a side panel widget (on the right hand side by default).
8.  **App Store (Extensions Marketplace) Integration:** Connect and configure the Open VSX registry for app discovery.
    - Implement a custom “App Store” view: Repurpose Theia’s built-in Extensions view (If removed, consider re-adding the minimal part required for extension installation). Duplicate this extension and convert the copied code into an "App Store" view instead. The functionality will be the same, but instead of targetting IDE extensions, it will allow for the discovery and installation of "Apps" (which are widgets/webviews packaged as VSIX packages, the same as extensions). We want to duplicate the existing "Extensions" view as we may still want to use that for adding actual extensions, so by creating a new view it keeps the concerns separate, allows for different registries, etc.
    - Instead of actually connecting to a registry at MVP stage, mock up a registry as JSON with a few sample "apps" listed in it, and "connect" to that in the "App Store" view.
    - Test within the running app: open the App Store view, search for a test extension (app) that we know is in our registry. Try installing it via the UI (Theia should download and unpack the VSIX automatically).
    - Confirm the extension activates or appears in the App Launcher. If the extension has a UI part, try launching it to verify installation was successful.
    - **Output:** A working in-app marketplace where users can browse and install new apps (extensions). This completes the self-service loop for extending the platform.
9.  **App Launcher/Dock Implementation:** Improve the user experience for launching installed apps.
    - Clone and repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar – a shortcut bar where installed apps can be pinned for one-click launching, similar to a taskbar. It should show icons for each installed app, with a separator to show which ones are currently in use in the current workspace, and then show the remaining ones which could be launched below.
    - Iterate over all "app" extensions and find those that have a certain flag in their extension manifest or package.json (we can define e.g. `"fdc3-app": true` in extension package to denote a user-launchable app). Then for each, create an icon entry in the app launcher bar.
    - Clicking the app entry should open its main view. If it’s a webview extension, that usually means executing a command that the extension registered (like `"extension.openXYZ"`). We might need to coordinate with each app developer to have a standardized open command.
    - Position this launcher to the left of the left hand pane, in the "Activity bar" space.
    - Test by installing a couple of sample apps and launching them via this UI. Also test edge cases: launching the same app twice (initially it should just focuses the existing - we may need a policy here, perhaps allow multiple instances if the extension supports it via a manifest entry, or prevent duplicates).
    - **Output:** A convenient app launching interface that enumerates and opens installed apps, making the workspace truly dynamic for the end user.
10. **AI Assistant Panel:** Integrate the AI chat functionality into the right sidebar.

    - Theia has an AI extension available: include it in our product and configure it. We want it visible, so consider auto-opening the AI widget on startup. It should live in the right hand sidebar by default.
    - (Optional integration) If possible, feed the current workspace’s context to the AI. This could mean including the last broadcast context in the prompt (if that context is not sensitive and could help the AI answer questions about the current client). This is advanced and might be deferred.
    - Test by asking a simple question in the AI panel and seeing that we get a response (assuming internet connectivity and a valid AI service).
    - **Output:** A functioning AI assistant view that users can interact with. Even if basic, it demonstrates the platform’s extensibility and provides a foundation for smarter features later.

11. **Documentation & Handover:**

    - Prepare developer documentation: how to build and run the platform, how to create a new app extension for it (including how to use the FDC3 API we provide, and how to package apps into VSIX).
    - Prepare user documentation: how to use workspaces, how to install apps from the store, how to use the context linking features, etc.
    - If open-sourcing the project, set up a repository with a clear README, contribution guidelines, and licensing info.
    - Plan next steps (future roadmap features like those deferred, e.g., multi-window, external integration, etc., so the team and community know what’s coming).
    - **Output:** Comprehensive documentation and a clear path for future work, marking the completion of this phase of the project.

12. **Testing and Stabilization:** Perform thorough testing and address issues.

    - Write unit tests for the DesktopAgent’s key methods (simulate multiple listeners, broadcasts, etc.).
    - Simulate a multi-workspace scenario: open two workspaces, each with a context and a couple of apps. Ensure that broadcasting in one does not affect the other.
    - Test installation and usage of a variety of apps: for example, one that only listens to context, one that raises intents, etc. This might involve creating mock/test extensions specifically for testing FDC3 flows.
    - User acceptance testing: get feedback on the UI/UX, refine the layout, tab behaviors, naming (rename “Extensions” view to “App Store”, etc., as needed for clarity).
    - Performance test: measure load time with several extensions, memory usage with multiple apps, etc., and optimize (e.g., lazy load certain extensions or close webviews when not visible).
    - **Output:** A release-candidate version of the platform, with bugs fixed and smooth user experience.

Each task above can be broken down further into sub-tasks during actual development, and tracked in our issue tracker. By completing these tasks in order, we will gradually transform a vanilla Theia IDE into the customized FDC3-enabled workspace platform we envision.

---
