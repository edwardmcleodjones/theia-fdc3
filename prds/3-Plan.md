# Theia-Based FDC3 Workspace Platform

## Plan

**Tech Stack Overview:** We will use **TypeScript** for all development (client and server), as Theia is built in TypeScript. The runtime environment is Node.js (for Theia backend) and a browser/Electron (for front-end). We use Theia's existing two build targets: a **web application** (Theia backend served via Node, front-end in browser) and a **desktop application** using **Electron** (packaged with electron-builder [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application) for Windows, Mac, Linux - initially only Windows). This dual deployment strategy ensures users can either access the platform via a URL or install it as a native-like app. We’ll follow Theia’s standard IDE blueprint structure which already separates an Electron build and a browser build in the project.

**Architecture and Components:**

- **Eclipse Theia Framework:** The core of our application. We will start from Theia IDE (formerly "Blueprint") (the example product) as a template. Theia provides the shell (window management, menus, docking areas) and services (commands, menus, keybindings, preference storage, etc.). Importantly, Theia’s extension model will allow us to add our custom functionality. We plan to **remove certain core extensions** from the default Theia assembly (e.g., file-system navigator, text editor, git, etc.) to declutter the UI.
  Conversely, we will **add custom extensions** to implement new features (workspace context management, FDC3, etc.). Theia’s flexibility means we can adapt the feature set with almost no limits: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20is%20based,to%20modify%20which%20VS%20Code), which suits our project. All of this can be done via an extension plugin, which can override everything in the base Theia application, via rebinding existing contributions or adding new ones, and filtering out unneeded parts via contribution filters.
- **Base Theia FDC3 extension"**: We will create an initial Theia extension (`theia-fdc3-extension`) that customizes the base Theia IDE setup to our needs. This extension will:
  - Remove unneeded core extensions (file explorer, text editor, git, etc.) to simplify the UI.
  - Add our custom extensions (Workspace Manager, Context & FDC3, App Launcher, etc.) to provide the required functionality.
  - Configure Theia settings (menus, keybindings, preferences) to suit our context-driven workspace model.
    This base extension serves as the glue that transforms Theia from a generic IDE into our specialized FDC3 workspace platform.
- **Custom Theia Extensions:** We then anticipate developing several in-house extensions (each likely as its own npm package inside a monorepo or as part of the Theia application). Key extensions include:
  - **Workspace Manager Extension:** Responsible for managing workspace contexts and the top-level “workspace tabs” UI. This extension will provide a UI element (a tab bar at the top and a custom panel) to create, switch, rename, and close workspaces. It will maintain an internal registry of current workspaces, each with an identifier and context data. It will intercept Theia’s usual concept of “workspace” – possibly by operating in _multi-root workspace mode_ or by tricking Theia into treating each context as a separate workspace without a folder. We might use Theia’s widget APIs to implement a tabbed container that shows/hides sets of widgets belonging to each workspace. Another responsibility of this extension is scoping broadcasts: it will likely instantiate or configure the FDC3 DesktopAgent on a per-workspace basis (e.g., one channel per workspace).
  - **Context & FDC3 Extension:** This is the core of inter-app communication. It will implement the FDC3 `DesktopAgent` interface. Likely, we will expose `window.fdc3` to the front-end environment so that any app (especially those running as webviews) can call it. In an Electron environment, we can inject a preload script to set up `window.fdc3`. In a pure browser environment, since all apps are within the Theia front-end, we can attach `fdc3` to the global window of the Theia iframe or use Theia’s command system to simulate it. Under the hood, this extension will manage:
    - A **message bus**: We will use Theia’s `EventEmitter` pattern: [theia-ide.org](https://theia-ide.org/docs/events/#:~:text=private%20onLogLevelChangedEmitter%20%3D%20new%20Emitter) or the JSON-RPC communication channel between frontend and backend to propagate events. For example, when an app calls `fdc3.broadcast(context)`, our implementation will fire an event to all listeners in the same workspace. Because Theia runs extensions in a separate process, we might keep the DesktopAgent mainly in the frontend (so it can directly notify other webview iframes or extensions) and use the backend only if cross-process communication is needed.
    - **Context Channels:** We will leverage FDC3’s channel concept. Upon workspace creation, we can create a dedicated channel (with a unique ID, e.g., “workspace-XYZ-channel”). When apps launch in that workspace, our DesktopAgent will automatically join them to that channel (this could be done implicitly by our container, even if the app isn’t aware). Thus, a broadcast will effectively be contained to that channel/workspace. We’ll implement `getOrCreateChannel`, `joinUserChannel`, etc., but we might abstract this so that from the user perspective they don’t manually join channels – the platform does it for them based on active workspace.
    - **Intent Resolution:** We’ll maintain a simple registry of intent handlers. For each app that wants to handle an intent, we’ll provide an API (like `fdc3.addIntentListener(intentName, handler)`) which our DesktopAgent extension will register. When some app raises an intent, the DesktopAgent will look up the appropriate handler (in the same workspace) and invoke it. If multiple apps can handle, we may need an intent resolution UI (like “Which app do you want to handle this?”). Initially, we can assume one handler per intent (to avoid UI complexity), or choose the first registered. This is an area for expansion (maybe a quick palette if multiple choices).
    - **App Directory for Intents (Minimal):** In absence of a full App Directory service right now, we will use the extension manifests to identify what intents each app can handle, in order to implement `findIntent` or `raiseIntentForContext` properly. For MVP, this could be hard-coded or using each extension’s package.json `fdc3` field if provided.
    - **Logging:** This extension will also hook into all context and intent events and push log entries to the Logging UI (likely by writing to a dedicated OutputChannel in Theia). It could also expose a simple logger interface for apps to log custom events if needed.
  - **App Launch/Dock Extension:** This will manage how apps are launched in a workspace. We will repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar. We can augment that to allow “opening” an extension’s contribution. For example, an extension (app) that contributes a widget or webview panel can have a command to open that panel. Our App Launch extension could read all installed extensions that are flagged as “workspace apps” and list them for the user. Clicking an app in the list would execute its “open” command to create a new panel in the current workspace. This extension also ties into the App Store: after installing a new app, it should appear in the launcher list..
  - **Custom UI Widget Extensions:** We will create some small extensions for specific UI widget elements:
    - _Client Picker Extension (Context Selector):_ A sample implementation of a context provider app that sits in the left sidebar. This extension could provide a tree or list of clients/projects (fetched from some API or a sample data source). When a user selects an item, the extension broadcasts an FDC3 context (e.g., `ClientContext` with the chosen client’s details) via the DesktopAgent. This will drive other apps to update. While this is technically an app, we might include it as a built-in example to demonstrate context setting. It will register itself as a left-panel widget.
    - _AI Assistant Extension:_ If Theia’s AI assistant ("AI Chat View") is available as a Theia extension, we will include that. If not, we’ll create an extension that provides a chat UI panel on the right. This panel might call an external AI service (OpenAI, etc.) or use Theia’s AI backend if configured. We’ll keep it decoupled so the AI service URL or key can be configured. The extension could listen for the current context (so if a user is asking a question, it can include the current workspace’s context data in the prompt, within security allowances).
    - _Theming/Branding Extension:_ While not core to functionality, we may include a small extension or config changes for custom branding (name, logos, maybe a custom welcome screen). This ensures the product feels cohesive and not just a generic IDE. This might involve overriding Theia’s About dialog and logos as per Theia customization guidelines: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=You%20can%20also%20add%20your,the%20installer%20can%20be%20customized).
  - **Notifications Extension:** We may not need a separate extension if Theia’s built-in `MessageService` or notification system suffices. But we might extend it to support richer notifications (with multiple action buttons or form inputs in notifications, similar to HERE’s advanced notifications: [here.io](https://www.here.io/here-core#:~:text=Notification%20Center)). If needed, this extension would provide an API like `showNotification(title, message, actions, context)` that apps can call (possibly via the DesktopAgent as well, or a separate import if they’re Theia extensions). Under the hood it could wrap Theia’s notification UI but also tie into FDC3 intents (e.g., if a notification’s button corresponds to an intent like “OpenTradeTicket”, clicking it triggers that intent).
- **Open VSX Registry (App Store backend):** For the MVP we will implement this as just a static JSON file that can be read in. Eventually, post MVP, We will set up a private instance of Eclipse OpenVSX. This is a separate piece (not part of Theia code) that we will host on a server accessible to the app. The OpenVSX deployment requires a database and some storage; we’ll follow Eclipse’s guide: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=Extension%20sources) to deploy it. The plan is to have full control over what apps/extensions are available – initially, we might populate it with only our known good apps. The Theia front-end can be configured (via `package.json` or an ENV variable) to use our registry endpoint instead of the default. This way, when the user opens the App Store view, it queries our registry. We also have the option to bundle some extensions pre-installed (built-ins) if certain apps are mandatory for all users.
- **Data Storage:** For the most part, the platform doesn’t need a central database – it’s a container. However, we will use Theia’s built-in storage for user preferences and state. Theia typically stores settings in JSON and can also retain UI layout between sessions. We will utilize these mechanisms to remember things like last open workspace or panel sizes. For any additional data (like saved workspace definitions, or user’s list of favorite apps for the dock), we can either use Theia’s preferences API or simply store in local storage (browser) / a config file on desktop. Given this is a client-side heavy app, no significant server component (besides the OpenVSX service) is planned initially.
- **Third-Party Libraries:** We will use FINOS FDC3 TypeScript definitions to ensure compliance (if available, e.g. `@finos/fdc3` npm package for types). We might also incorporate a message routing library if needed, but likely Theia’s own event emitters suffice. For the AI extension, integration with an external API (OpenAI, etc.) will be done carefully (maybe using Theia AI extension or a direct call with fetch in the extension). We need to be mindful of any licensing – Theia is EPL/Apache licensed, our code will follow compatible licensing (likely Apache 2.0 or similar).
- **Deployment and Build Process:** We plan to keep the build process aligned with Theia’s recommended approach:
  - Use **Yarn** workspaces and Lerna (Theia’s monorepo uses Lerna) to manage extensions and the overall application.
  - For the Electron app: use `yarn electron build` to produce installers for each OS: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application). We’ll set up signing for Windows/macOS as needed (likely later, for distribution).
  - For the browser version: we can run Theia backend with `yarn start` (or a PM2 process in production). Optionally, containerize it with Docker for easy deployment on a server.
  - Continuous Integration: We’ll have CI scripts to build both versions and possibly publish the web version Docker image and the Electron artifacts.
  - We will also deploy our OpenVSX registry as a separate service (perhaps Dockerized as well). That requires periodic maintenance (to publish new app entries). In development, we might skip it and allow installing from the public OpenVSX, but production will use the private one.
- **Testing Strategy:** The plan will include a thorough testing approach: For the MVP we will keep tests minimal and lightweight, and rely on Theia's existing test suite, extending it where it makes sense without adding new dependencies. In future, we will consider the following:
  - **Unit Tests:** for the logic of context handling, intent routing, etc., using a framework like Mocha or Jest in the Theia environment.
  - **Integration Tests:** possibly using Theia’s built-in test support or Spectron (for Electron) to simulate user interactions: e.g., open two apps, broadcast a context, verify the other app received it.
  - **Manual Testing:** since UI/UX is crucial, we’ll have a period of manual testing to check that the workspace isolation feels correct, apps update as expected, and the UI remains responsive with multiple apps.
  - We also want to test both in Electron and pure browser to catch any differences (like `window.fdc3` injection might differ).

* **Future Architecture Considerations:** As the platform grows, we should keep in mind:
  - Possibly splitting out the DesktopAgent to a shared service if multiple windows are needed (e.g., an external process that all windows connect to, akin to OpenFin’s core).
  - Scaling the OpenVSX or moving to a more specialized app directory if needed for performance or richer metadata.
  - Adding a backend component for things like user login or data caching if we integrate with external data sources (for now, each app extension could directly fetch data from APIs, but a unified backend could mediate if needed later).

In summary, the plan is to **utilize Theia’s extension-based architecture** to transform the IDE into a context-driven workspace container. We carefully choose tech that aligns with Theia (TypeScript, VS Code extension format, Electron) to minimize risk. Each needed feature is an extension or configuration change, which keeps the design clean. The architecture favors an in-process event driven approach (since everything runs within the Theia container process or plugin process) for speed. We will document our extensions well so that others can build on this platform, following the open-source spirit.

**Technical Architecture Overview:** The Theia FDC3 Platform will be implemented as a custom **Eclipse Theia application** composed of multiple extensions. The architecture follows Theia’s front-end/back-end split: a browser-based **frontend** (responsible for rendering the UI and handling user interactions) and a Node.js **backend** (responsible for heavy logic, integration with OS or external services, and as a server for the frontend)[theia-ide.org](https://theia-ide.org/docs/architecture/#:~:text=Theia%20is%20designed%20to%20work,run%20on%20a%20remote%20host). In an Electron build, both frontend and backend run on the user’s machine (the backend as a background Node process, the frontend in an Electron BrowserWindow)[theia-ide.org](https://theia-ide.org/docs/architecture/#:~:text=Theia%20is%20designed%20to%20work,run%20on%20a%20remote%20host). In a cloud scenario, the backend runs on a remote server and the frontend in the user’s web browser; communication happens via WebSocket/JSON-RPC which Theia handles transparently.

We will create dedicated Theia **extensions** for each major feature set. Each extension will contribute frontend UI components (via React widgets or Theia widget classes) and backend services or handlers as needed. The separation of extensions allows parallel development and clarity. Below is a breakdown of planned components/extensions:

- **Workspace Manager Extension (UI Shell)**: This module handles the overall layout and UI chrome of the application. It will extend and customize Theia’s default shell. Key responsibilities:
  - Provide a **custom frontpage or window** when the application loads (e.g. a welcome or an overview of how to open apps).
  - Implement the **multi-app workspace** interface: the ability to open apps in tabs/panels, create and switch workspace tabs (if implementing multiple named workspaces concurrently as per spec), and arrangements like tiling. We leverage Theia’s existing docking and widget system for this[theia-ide.org](https://theia-ide.org/docs/project_goals/#:~:text=Basic%20Workbench%20Frame). Each app instance will likely be encapsulated in a Theia `Widget` (which can host an `<iframe>` or an embedded browser view for an external app’s content, or as a VS Code style extension).
  - Manage menu/toolbar contributions: e.g., a “Launch App” button (with a ‘+’ icon) in a corner to open the App Directory panel, or a dropdown to switch workspaces, etc. The extension will use Theia’s command and menu registry to add these UI controls.
  - This extension also persists layout state – we will use Theia’s layout restoration mechanism to remember which apps were open in each workspace and their sizes/positions, so that users can reload the platform and get back to where they left off.
  - _Tech:_ Frontend heavy (UI components possibly in React or Phosphor widgets), minimal backend (maybe to read/write workspace state to disk). We might subclass Theia’s `ApplicationShell` or manage multiple shells if supporting distinct “workspace tabs.”
- **FDC3 Desktop Agent Extension (Interop Service)**: This is the core logic implementing the FDC3 API. It will likely be split between:
  - **Backend service**: A singleton “DesktopAgentService” that holds the state of running apps, channels, listeners, etc. This could be implemented as a Node backend contribution that other extensions can access (via dependency injection). It will implement functions corresponding to the FDC3 API (`open`, `broadcast`, `raiseIntent`, etc.), managing the data structures (list of channels, mapping of intent to apps from the directory, tracking context listeners, etc.).
  - **Frontend proxy**: In the browser, FDC3 calls from apps need to reach the backend service. For apps running in iframes, we’ll implement the **FDC3 Web Connection Protocol** – possibly by injecting a small script into each app iframe that listens for `window.fdc3` requests or employs the standardized `getAgent()` handshake[fdc3.finos.org](https://fdc3.finos.org/docs/next/api/supported-platforms#:~:text=The%20recommended%20way%20to%20get,Desktop%20Agents%20for%20web%20applications)[fdc3.finos.org](https://fdc3.finos.org/docs/next/api/supported-platforms#:~:text=,Agent%20API%20is%20used%20to). We might create a hidden iframe or use the parent window as the broker for these messages. Concretely, when an app calls `fdc3.raiseIntent`, the call (via postMessage or the injected object in Electron) will be handled by our frontend code, which then forwards it to the backend DesktopAgentService via an RPC call. The backend performs the logic (find target, etc.), then instructs the frontend (maybe via an event) to, for example, open the target app’s widget and deliver the context to it.
  - **Intent Resolver UI**: Part of this extension (frontend) will be a UI component that pops up when `raiseIntent` requires user input (multiple possible handlers). We’ll design a modal or dropdown listing the app options (with icons and descriptions from the directory) and let the user choose. Once chosen, that decision is sent back to the backend to complete the intent raising (launch the app if not open, etc.). This UI will use Theia’s dialog or widget system, most likely the same system as that used for showing the "Command Palette" or other modals.
  - **Channel management UI**: [OUT OF INITIAL SCOPE] To enable channel linking, we may include a simple UI element (like a channel selector) for each app widget or a global channel indicator. For instance, a colored circle that when clicked shows available **user channels** and allows the user to join the entire workspace or a specific app to a channel. Alternatively, channels can be managed programmatically (apps join default global channel unless user changes). If using explicit UI, this extension would contribute that (e.g., as part of each widget’s title bar or a status bar item listing current channel).
  - _Tech:_ This extension will use TypeScript extensively. We will use the **@finos/fdc3 NPM packages** for type definitions and perhaps for certain helpers (like the `getAgent()` logic). The backend service might maintain in-memory structures: e.g., `listeners` map to callback functions (the actual callbacks likely reside in the app iframes; we’ll forward contexts to them via postMessage). We must handle unique IDs for listeners, etc. Testing this component is a priority (using the FDC3 conformance tests in headless mode to validate our implementation).
  - We will also ensure **compliance**: e.g., implement optional methods like `getInfo()`, and label ourselves with an `implementationMetadata` including the platform name and version. This extension effectively transforms Theia into a functioning **FDC3 Desktop Agent**.
- **App Store Extension (Launcher)**: We will clone and adapt Theia’s existing **Extension Manager** extension, which provides an “App Store” UI for browsing and installing VS Code/Theia extensions from an OpenVSX registry. Our customized version will:
  - Provide a dedicated **App Store view** (a panel or tab) that lists available FDC3-compatible apps/extensions from our configured OpenVSX registry (initially a static JSON file, later a private OpenVSX instance).
  - Allow users to **search, filter, and browse** apps by categories, intents handled, or keywords. We can enhance the UI to highlight which intents each app supports (by reading metadata from the extension manifest).
  - Enable users to **install/uninstall** apps directly from the store. Installing an app means adding the corresponding Theia extension to the running application (Theia supports dynamic extension loading). We will handle any necessary prompts or confirmations.
  - After installation, the app should appear in the **App Launcher/Dock** (another extension) for easy access.
  - _Tech:_ This extension will heavily reuse Theia’s existing Extension Manager codebase, adapting it to our needs. We will modify the registry URL to point to our OpenVSX instance or static JSON. The UI will be React-based (as per Theia’s standard). We may need to extend the extension manifest schema to include FDC3-specific metadata (like intents handled) if not already present.
- **App Directory Extension (Launcher)**: [OUT OF INITIAL SCOPE] This handles integration with the App Directory and launching of apps.
  - It will include a **backend component** that knows how to fetch or load the app directory data. For a FINOS AppD service, this may involve calling REST endpoints (`/v2/apps` etc.) to retrieve JSON of app definitions. We might incorporate the FINOS sample directory (which is essentially a static JSON or a small service). Caching and offline mode will be considered: perhaps on first run the directory is fetched and then cached to a file or localStorage for quick subsequent loads.
  - On the frontend side, this extension provides the **App Catalog UI** – a panel (likely docked as a side view) listing all available apps with their icons, names, and maybe categories/intents. We’ll allow filtering/search by name or intent keyword. The list could be simply a tree or grid of app icons. Selecting an app will show its details (description, maybe screenshots if provided, list of intents it handles for transparency). And a prominent **“Open”** button to launch it. This UI uses the data from the backend service (which holds the app directory entries).
  - The actual logic of launching an app when requested: the App Directory entry includes details like the app’s **URL** (for web apps) or instructions for native apps (if any; but our platform likely focuses on web apps via URL). The extension will call the DesktopAgentService’s `open` function with the selected app’s identity, which triggers the creation of a new widget/iframe for that app URL. We’ll ensure to pass along any initial context if needed (for example, if launch was triggered as part of intent resolution, context goes through).
  - If the directory indicates the app needs to be downloaded or uses a specific manifest (e.g., it might reference a web app manifest or an OpenFin manifest), we have to handle that. Likely we focus on web URLs and basic Electron support (which can just open a browser view to that URL).
  - This extension also can handle **directory search** programmatically – e.g., implementing `findIntent` and `findIntentsByContext` by querying the app directory data for matches[fdc3.finos.org](https://fdc3.finos.org/docs/api/ref/DesktopAgent#:~:text=%2F%2F%20intents%20findIntent,IntentResolution)[fdc3.finos.org](https://fdc3.finos.org/docs/api/ref/DesktopAgent#:~:text=findIntent,IntentResolution%3E%3B%20addIntentListener%28intent%3A%20string%2C%20handler%3A%20IntentHandler). That way, the DesktopAgent extension can use it to resolve intents.
  - _Note:_ We might combine the Directory and DesktopAgent into one extension for simplicity (since they are tightly coupled – the Desktop Agent needs the directory). However, separating them keeps responsibilities clear (one deals with data/catalog, the other with runtime orchestration).
  - _Tech:_ Standard REST calls (could use fetch or axios) for directory queries; JSON parsing of app manifests. We must also define a TypeScript interface for App Directory entries (the FDC3 schema) and possibly generate code from the FDC3 AppD OpenAPI spec[fdc3.finos.org](https://fdc3.finos.org/schemas/2.0/app-directory#:~:text=FDC3%20Application%20Directory%20%282,interface%20definition%20and%20objects)[github.com](https://github.com/finos-labs/FDC3-App-Directory#:~:text=finos,0%20Compatible%20Desktop%20Agent). Caching can use Node filesystem or browser localStorage depending on environment.
- **Notification & Logging Extension**: This provides the supportive infrastructure for user notifications and log output.
  - For **notifications**, we will leverage Theia’s built-in `MessageService` which can be injected and used to show info/warn/error messages easily[theia-ide.org](https://theia-ide.org/docs/message_service/#:~:text=The%20message%20service%20allows%20you,see%20code%20example%20below). We will likely wrap it in our own service that other parts of our platform can call. For example, when the DesktopAgent service catches an error (like an app’s URL fails to load, or no handler for an intent), it can call `NotificationService.showError("No application available to handle this action")`, which internally calls `MessageService.error(...)` to display a toast[theia-ide.org](https://theia-ide.org/docs/message_service/#:~:text=By%20default%2C%20Theia%20will%20display,MessageClient). We ensure consistent formatting of messages (maybe include the platform name or relevant icon). This extension might also listen for certain events to automatically generate notifications – e.g., after launching a new app, it could show “✅ App X opened successfully” (likely as a low-priority info toast).
  - For **logging**, on the backend we will maintain a log buffer (append entries as events happen). We will define a LogEntry structure (timestamp, source, message, maybe level). The extension will expose a backend interface to add log entries. On the frontend, we’ll have a **Log Viewer** widget that can show the log entries in a scrollable view (utilizing Theia’s “Debug Console” or general Output view). We will reuse Theia’s Output channel mechanism by creating a custom output channel for “FDC3 Platform Logs” and writing to it – this would automatically integrate with Theia’s Output panel UI. In future we may implement a custom widget for more control (especially if we want to filter by event types, etc.).
  - The log viewer should have controls like clear, save (export to file), and maybe adjustable verbosity (if we have log levels). For development, we might log very verbosely (each FDC3 API call and internal decision), whereas production might default to warnings/errors only unless a debug mode is enabled.
  - This extension may also integrate with browser devtools/Electron devtools – not directly, but we will ensure that `console.log` statements are used appropriately so that developers can see messages in the console as well. In Electron, perhaps write to a file under user’s home (for support to gather logs).
  - _Tech:_ Fairly straightforward Theia usage. We will use dependency injection to allow any extension to get a handle to the LoggingService and NotificationService. Concurrency considerations: if multiple events happen rapidly, our logging should handle multi-thread (Node is single-threaded but async events) – basically just ensure append is atomic. The UI should update in near-real-time as new logs arrive (maybe using Theia’s EventEmitter pattern to notify the log widget of new entries).
- **AI Assistant Extension**: This is a self-contained module providing the AI chat UI and connecting to Theia AI functionalities.
  - **Frontend (AI Chat Widget)**: Theia AI actually provides a ready-made customizable chat view component[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=5,widgets%2C%20may%20it%20be%20textual), which we will reuse / integrate with. It supports rendering markdown, code, and has hooks for adding custom buttons (which we might use to let the AI output interactive suggestions, e.g., “Open this chart” button alongside an answer). If possible, we integrate with that directly to avoid building UI from scratch.
  - **AI Agents and Backend**: Using Theia AI’s framework, we will configure an **AI agent** tailored for our platform. For example, an agent that has access to certain tool functions: it could call a function like `listOpenApps()` or `openApp(name)` or even `getContextFromApp(app, type)` – we can register these as functions the LLM can use (Theia AI supports function calling paradigm[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=1,JSON%20following%20a%20specific)). This way, if the user asks something that requires action, the AI can invoke those functions (within constraints we set). The agent will have a prompt context describing the platform (we’ll feed it some information about what apps are open, or what data is available in each, if feasible).
  - We will support multiple AI backends: initially likely OpenAI’s GPT via API (for which Theia AI has integration), but also allow configuration for an open-source model or other provider[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=chain,optionally%20even%20make%20the%20LLM)[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=2,agents%20dynamically%20communicate%20with%20each). This might be done via Theia preferences (so user can paste an API key, select model).
  - The extension will manage the conversation state (could be ephemeral or saved per session; probably ephemeral due to potential sensitivity of data). If allowed by company policy, we might let the user save a conversation or extract an answer.
  - Importantly, we incorporate **guardrails**: limit which functions the AI can call and ensure any action it proposes is confirmed by the user. For instance, if the AI decides it wants to open an app or broadcast a context, we might intercept and ask user “The assistant wants to open App X with context Y – allow?”. This prevents unexpected actions.
  - This extension will be largely built on top of **Theia AI** (which as of v1.54 is available in beta[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=Theia%20AI%20is%20part%20of,community%20into%20the%20generic%20framework)). We will utilize its APIs for LLM communication and agent management instead of writing our own low-level LLM calls. This saves a ton of effort as noted[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=1,JSON%20following%20a%20specific). We just need to define our agent’s behavior and any custom prompt templates (Theia AI also has prompt template registries[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=3,or%20users%2C%20enabling%20a%20collaborative), which we can use to format queries, possibly injecting currently selected context, etc., if user asks something context-specific).
  - _Tech:_ Requires including the `@eclipsesource/theia-ai` extension or similar. Our code will be in TS, orchestrating the agent. We might write some Python or use a cloud function if we had to, but since Theia AI wraps that, we stay in TS land. We should plan for this extension to be optional at runtime (so if AI is disabled, the rest of platform works fine).

**Integration & Communication Logic:** The extensions above must work in concert. We outline some key integration points and how data flows through the system:

- _Opening an App:_ Initially, "apps" will be packaged as VSIX "extensions", and the existing Theia mechanisms used to open and manage them. [FUTURE SCOPE] When a user chooses an app from the App Directory UI or an FDC3 `open` call is made, the request goes to the DesktopAgent service. That service uses the App Directory service to fetch the app’s manifest (if not already cached) and resolve the launch details (URL, perhaps startup params). The Workspace/UI extension is then instructed (via frontend RPC or an event) to create a new iframe widget for that URL. That widget, upon creation, will load the app. We ensure that before the app’s code runs, it can connect to `fdc3`: in Electron, we use a preload script to attach `window.fdc3`; in browser, the app will likely use `getAgent()` which triggers our WCP handshake. In both cases, our DesktopAgent extension will finalize a `fdc3` proxy object for the app to use[fdc3.finos.org](https://fdc3.finos.org/docs/next/api/supported-platforms#:~:text=,Agent%20API%20is%20used%20to). The app then appears in the UI. The DesktopAgent service keeps track of this instance (so further opens don’t duplicate it, unless multiple instances are allowed explicitly).
- _Broadcasting Context:_ If App A broadcasts context X, the call is caught by our desktop agent API (frontend) and sent to the backend. The DesktopAgent service checks: which channel is App A on? It then finds all other app instances joined to that channel, and for each, sends the context to it (provided those apps have listeners for that context type or wildcard). The actual sending might be done by posting a message into the iframe’s contentWindow (since we can call into the app’s context via the browser). The receiving app’s `fdc3.addContextListener` handler then triggers inside the app. This all happens asynchronously. If no app is on the same channel or no listeners, nothing visible happens (we might log that context was broadcast with no receivers). If some app is on the **global default channel** with App A (the default case if user didn’t change channels), all apps on default get it – effectively broadcasting platform-wide unless isolated channels are used.
- _Raising Intent:_ If App A raises an intent Y with context C. Backend gets it, queries App Directory for handlers of intent Y (filtered by context type of C if provided). Suppose it finds App B and App C can handle it. Because multiple exist, the backend puts those options in a list and notifies the frontend to open the Intent Resolver UI. User picks App B. The resolver UI tells backend “use B”. The DesktopAgent now either finds an existing instance of B or launches B via the App Directory (similar to `open`). When B is ready (maybe we ensure it’s loaded and its `fdc3.addIntentListener` for Y has been registered – we might need a slight handshake to confirm the app is ready to receive), then we deliver the context C to B’s listener. Additionally, the DesktopAgent returns an **IntentResolution** to App A’s original call, indicating it was handled by B. If only one handler was found in the first place, we skip user choice and go straight to launching or using that one. If none found, we trigger a notification: “No application available for intent Y” (which our Notification extension displays) and maybe an error is returned to App A.
- _App Directory Sync:_ [OUT OF INITIAL SCOPE] On startup, the App Directory extension fetches the latest app list. It might periodically refresh (maybe a timed interval or a manual refresh button in the UI). If the directory updates (new app added), the UI list updates. Also, certain actions like searching by intent from an intents panel could query the directory on the fly.
- _Channel Join UI:_ If implemented, when a user manually switches an app’s channel (say from default to “Red”), the UI will call the DesktopAgent’s `joinUserChannel(appId, "red")`. The service will record that mapping. Perhaps also broadcast the last known context on that channel to the app immediately (FDC3 does something like that when joining, the app can optionally get the current context on the channel). We will follow the spec for channel behavior.
- _Notifications:_ All parts of the system will route user-facing messages through the Notification service. For example, if the App Directory fetch fails (network down), the directory extension will invoke `notify.error("Cannot reach App Directory server")`. If the AI assistant finishes a long answer, it might do `notify.info("Answer ready")` to prompt the user to open the assistant panel. Internally, the Notification service uses Theia’s MessageService so these calls result in consistent toasts[theia-ide.org](https://theia-ide.org/docs/message_service/#:~:text=By%20default%2C%20Theia%20will%20display,MessageClient).
- _Logging:_ Each extension will call Logging service for notable events. The DesktopAgent logs every FDC3 API call and result (for debug/tracking). The App Directory logs when it updates the app list. The AI assistant might log queries and actions (with careful consideration to not log sensitive user queries unless needed). All these logs funnel to the same sink. The Log viewer displays them tagged by component or severity. This helps developers see the interactions end-to-end (e.g., user clicked open app -> directory says URL -> agent launched it -> app connected).
- _AI Assistant workflow:_ When the user enters a prompt, the AI extension sends it to the LLM via Theia AI’s API. We likely show a “Typing…” indicator. The AI might produce an answer or decide it needs to perform an action. Thanks to Theia AI’s design, if the model triggers a function call (like our `openApp` function), our agent code will intercept that, pause the LLM’s response, execute the function (e.g., call DesktopAgent.open for the specified app), then resume or adjust the prompt with the result. For example, if user asked for a chart of IBM, the AI might call `openApp("ChartViewer", context=IBM)`. We then open that app (DesktopAgent does this as usual). We might feed back to the AI something like “App opened.” Then the AI concludes, and we display the answer (“Opened ChartViewer for IBM 👍”). All of this is speculative, but it’s how we can integrate AI with FDC3 – treating the DesktopAgent as a set of tool functions the AI can utilize[eclipsesource.com](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/#:~:text=4,This%20allows%20controlling%20LLM%20interactions). Initially, though, the AI may be used in a simpler Q&A manner (like a help chatbot for FDC3 concepts). The architecture, however, will be prepared for deeper integration.

**Tech Stack Choices:**

- _Language:_ **TypeScript** for all front-end and back-end code (consistent with Theia). HTML/CSS for any custom styling of panels.
- _Frameworks:_ Theia’s own framework and dependency injection (Inversify) will be used to wire services. Theia’s default UI uses Lumino widgets and some React; we’ll use **React** for implementing complex UI elements (e.g., App Directory grid, Intent chooser) since Theia allows using React inside widgets. The AI chat might reuse existing React components from Theia AI.
- _Libraries:_ **@finos/fdc3** for API types and possibly for `getAgent()` polyfill. For App Directory, if FINOS provides a JavaScript client or OpenAPI spec, we might codegen a client; otherwise manual fetch/HTTP using `node-fetch` or Axios. Logging might use a library for formatting if needed (or just plain strings). The Electron packaging will rely on Theia’s build (which uses webpack) and the Electron Builder or similar to produce executables.
- _Storage:_ Minimal – some config (like last used workspace, or user preferences such as AI model API key) will be stored using Theia’s Preferences API (which can persist to disk or browser local storage). We are not storing large data sets; the App Directory cache JSON might be stored in a file. Logs might be written to a file (text or JSON lines) if persistence needed.
- _Testing:_ We plan to write unit tests for critical functions (especially the DesktopAgent logic – e.g., does raiseIntent correctly filter by context?). We can use Jest or Mocha as in Theia projects. Integration testing could involve launching the platform and using a headless browser to simulate app behavior (possibly using the FDC3 Workbench app to drive tests[github.com](https://github.com/finos/FDC3-Sail#:~:text=The%20FDC3%20Workbench%20is%20a,file)). Also, we will utilize FINOS’s FDC3 conformance test suite[fdc3.finos.org](https://fdc3.finos.org/docs/api/ref/DesktopAgent#:~:text=): it's a series of tests that call the FDC3 API and expect certain behaviors. We will run those in our environment to ensure compliance. For UI, manual testing will verify that the workflow is smooth and that all pieces (launching apps, sharing context, etc.) work as intended.

**Extension Structure:** (summarizing how code will be organized)  
Each extension will have the typical Theia project structure: `package.json` (declaring dependencies and Theia contribution points), a `frontend` module and/or `backend` module. For example, `theia-fdc3-agent-extension` might have:

- `frontend/agent-frontend-contribution.ts` registering menus (maybe channel UI), injecting the `window.fdc3` in Electron, etc.
- `backend/agent-backend-contribution.ts` binding the DesktopAgentService in the DI container.
- Common folder for shared constants or types (like our LogEntry interface).  
  Likewise, the App Directory extension will have a backend part for fetching data, and a frontend part for the UI panel. We must list these extensions in the Theia application package to be included in the final build.

**Integration with Theia AI:** We will include the Theia AI extension as a dependency. Our AI Assistant extension will likely register a custom agent via Theia AI’s API (so that it’s loaded on startup). We will follow examples from Theia AI documentation to wire this up, ensuring our agent is configured with needed tools and prompt templates.

**Deployment Architecture:** The final application can be packaged as:

- An **Electron app** for Windows, Mac, Linux – (initially just Windows) - including all extensions and possibly the Node backend embedded. We’ll configure Electron’s `BrowserWindow` to enable a preload script that sets up `window.fdc3` for compatibility with older apps (FDC3 1.x style).
- A **browser app** – essentially a bundle that can be deployed on a server (with Node backend). This would allow users to access the platform via a URL. We will use Theia's packaging and deployment mechanisms for easy deployment, and instructions to configure the App Directory URL, etc., via environment variables or config files.  
  The plan is to use Theia’s build tools (they have a template for packaging custom products). We ensure all environment-specific code is placed in the correct `browser/` vs `electron/` folders per Theia conventions[theia-ide.org](https://theia-ide.org/docs/architecture/#:~:text=In%20an%20extension%27s%20top%20folder,folders%20to%20separate%20by%20platform) so that it’s included/excluded appropriately.

By outlining the above architecture and components, we ensure each feature is accounted for with a clear implementation strategy. The use of Theia means we start with a robust foundation (window management, extension framework, AI hooks), and we fill in the domain-specific pieces (FDC3 bus, app launcher, etc.). This plan emphasizes **loose coupling** – for instance, the DesktopAgent uses an App Directory interface, rather than being hardcoded to a specific source, making it easier to swap directories or even connect to multiple sources if needed. It also ensures maintainability: each extension can be developed and tested somewhat independently (with mocks for others), and future contributors can locate functionality (e.g., all AI-related code in the AI extension).

We will proceed by implementing the core backbone first (basic workspace + basic FDC3 open/broadcast with a simple hardcoded app entry for testing), then gradually integrate each additional feature (directory, intents, notifications, etc.) as described.
