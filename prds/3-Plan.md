# Theia-Based FDC3 Workspace Platform

## Plan

**Tech Stack Overview:** We will use **TypeScript** for all development (client and server), as Theia is built in TypeScript. The runtime environment is Node.js (for Theia backend) and a browser/Electron (for front-end). We use Theia's existing two build targets: a **web application** (Theia backend served via Node, front-end in browser) and a **desktop application** using **Electron** (packaged with electron-builder [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application) for Windows, Mac, Linux - initially only Windows). This dual deployment strategy ensures users can either access the platform via a URL or install it as a native-like app. We’ll follow Theia’s standard IDE blueprint structure which already separates an Electron build and a browser build in the project.

**Architecture and Components:**

- **Eclipse Theia Framework:** The core of our application. We will start from Theia IDE (formerly "Blueprint") (the example product) as a template. Theia provides the shell (window management, menus, docking areas) and services (commands, menus, keybindings, preference storage, etc.). Importantly, Theia’s extension model will allow us to add our custom functionality. We plan to **remove certain core extensions** from the default Theia assembly (e.g., file-system navigator, text editor, git, etc.) to declutter the UI.
  Conversely, we will **add custom extensions** to implement new features (workspace context management, FDC3, etc.). Theia’s flexibility means we can adapt the feature set with almost no limits: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20is%20based,to%20modify%20which%20VS%20Code), which suits our project. All of this can be done via an extension plugin, which can override everything in the base Theia application, via rebinding existing contributions or adding new ones, and filtering out unneeded parts via contribution filters.
- **Base Theia FDC3 extension"**: We will create an initial Theia extension (`theia-fdc3-extension`) that customizes the base Theia IDE setup to our needs. This extension will:
  - Remove unneeded core extensions (file explorer, text editor, git, etc.) to simplify the UI.
  - Add our custom extensions (Workspace Manager, Context & FDC3, App Launcher, etc.) to provide the required functionality.
  - Configure Theia settings (menus, keybindings, preferences) to suit our context-driven workspace model.
    This base extension serves as the glue that transforms Theia from a generic IDE into our specialized FDC3 workspace platform.
- **Custom Theia Extensions:** We then anticipate developing several in-house extensions (each likely as its own npm package inside a monorepo or as part of the Theia application). Key extensions include:
  - **Workspace Manager Extension:** Responsible for managing workspace contexts and the top-level “workspace tabs” UI. This extension will provide a UI element (a tab bar at the top and a custom panel) to create, switch, rename, and close workspaces. It will maintain an internal registry of current workspaces, each with an identifier and context data. It will intercept Theia’s usual concept of “workspace” – possibly by operating in _multi-root workspace mode_ or by tricking Theia into treating each context as a separate workspace without a folder. We might use Theia’s widget APIs to implement a tabbed container that shows/hides sets of widgets belonging to each workspace. Another responsibility of this extension is scoping broadcasts: it will likely instantiate or configure the FDC3 DesktopAgent on a per-workspace basis (e.g., one channel per workspace).
  - **Context & FDC3 Extension:** This is the core of inter-app communication. It will implement the FDC3 `DesktopAgent` interface. Likely, we will expose `window.fdc3` to the front-end environment so that any app (especially those running as webviews) can call it. In an Electron environment, we can inject a preload script to set up `window.fdc3`. In a pure browser environment, since all apps are within the Theia front-end, we can attach `fdc3` to the global window of the Theia iframe or use Theia’s command system to simulate it. Under the hood, this extension will manage:
    - A **message bus**: We will use Theia’s `EventEmitter` pattern: [theia-ide.org](https://theia-ide.org/docs/events/#:~:text=private%20onLogLevelChangedEmitter%20%3D%20new%20Emitter) or the JSON-RPC communication channel between frontend and backend to propagate events. For example, when an app calls `fdc3.broadcast(context)`, our implementation will fire an event to all listeners in the same workspace. Because Theia runs extensions in a separate process, we might keep the DesktopAgent mainly in the frontend (so it can directly notify other webview iframes or extensions) and use the backend only if cross-process communication is needed.
    - **Context Channels:** We will leverage FDC3’s channel concept. Upon workspace creation, we can create a dedicated channel (with a unique ID, e.g., “workspace-XYZ-channel”). When apps launch in that workspace, our DesktopAgent will automatically join them to that channel (this could be done implicitly by our container, even if the app isn’t aware). Thus, a broadcast will effectively be contained to that channel/workspace. We’ll implement `getOrCreateChannel`, `joinUserChannel`, etc., but we might abstract this so that from the user perspective they don’t manually join channels – the platform does it for them based on active workspace.
    - **Intent Resolution:** We’ll maintain a simple registry of intent handlers. For each app that wants to handle an intent, we’ll provide an API (like `fdc3.addIntentListener(intentName, handler)`) which our DesktopAgent extension will register. When some app raises an intent, the DesktopAgent will look up the appropriate handler (in the same workspace) and invoke it. If multiple apps can handle, we may need an intent resolution UI (like “Which app do you want to handle this?”). Initially, we can assume one handler per intent (to avoid UI complexity), or choose the first registered. This is an area for expansion (maybe a quick palette if multiple choices).
    - **App Directory for Intents (Minimal):** In absence of a full App Directory service right now, we will use the extension manifests to identify what intents each app can handle, in order to implement `findIntent` or `raiseIntentForContext` properly. For MVP, this could be hard-coded or using each extension’s package.json `fdc3` field if provided.
    - **Logging:** This extension will also hook into all context and intent events and push log entries to the Logging UI (likely by writing to a dedicated OutputChannel in Theia). It could also expose a simple logger interface for apps to log custom events if needed.
  - **App Launch/Dock Extension:** This will manage how apps are launched in a workspace. We will repurpose the existing Theia/VS Code "Activity bar" as a Dock or App Launcher toolbar. We can augment that to allow “opening” an extension’s contribution. For example, an extension (app) that contributes a widget or webview panel can have a command to open that panel. Our App Launch extension could read all installed extensions that are flagged as “workspace apps” and list them for the user. Clicking an app in the list would execute its “open” command to create a new panel in the current workspace. This extension also ties into the App Store: after installing a new app, it should appear in the launcher list..
  - **Custom UI Widget Extensions:** We will create some small extensions for specific UI widget elements:
    - _Client Picker Extension (Context Selector):_ A sample implementation of a context provider app that sits in the left sidebar. This extension could provide a tree or list of clients/projects (fetched from some API or a sample data source). When a user selects an item, the extension broadcasts an FDC3 context (e.g., `ClientContext` with the chosen client’s details) via the DesktopAgent. This will drive other apps to update. While this is technically an app, we might include it as a built-in example to demonstrate context setting. It will register itself as a left-panel widget.
    - _AI Assistant Extension:_ If Theia’s AI assistant ("AI Chat View") is available as a Theia extension, we will include that. If not, we’ll create an extension that provides a chat UI panel on the right. This panel might call an external AI service (OpenAI, etc.) or use Theia’s AI backend if configured. We’ll keep it decoupled so the AI service URL or key can be configured. The extension could listen for the current context (so if a user is asking a question, it can include the current workspace’s context data in the prompt, within security allowances).
    - _Theming/Branding Extension:_ While not core to functionality, we may include a small extension or config changes for custom branding (name, logos, maybe a custom welcome screen). This ensures the product feels cohesive and not just a generic IDE. This might involve overriding Theia’s About dialog and logos as per Theia customization guidelines: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=You%20can%20also%20add%20your,the%20installer%20can%20be%20customized).
  - **Notifications Extension:** We may not need a separate extension if Theia’s built-in `MessageService` or notification system suffices. But we might extend it to support richer notifications (with multiple action buttons or form inputs in notifications, similar to HERE’s advanced notifications: [here.io](https://www.here.io/here-core#:~:text=Notification%20Center)). If needed, this extension would provide an API like `showNotification(title, message, actions, context)` that apps can call (possibly via the DesktopAgent as well, or a separate import if they’re Theia extensions). Under the hood it could wrap Theia’s notification UI but also tie into FDC3 intents (e.g., if a notification’s button corresponds to an intent like “OpenTradeTicket”, clicking it triggers that intent).
- **Open VSX Registry (App Store backend):** For the MVP we will implement this as just a static JSON file that can be read in. Eventually, post MVP, We will set up a private instance of Eclipse OpenVSX. This is a separate piece (not part of Theia code) that we will host on a server accessible to the app. The OpenVSX deployment requires a database and some storage; we’ll follow Eclipse’s guide: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=Extension%20sources) to deploy it. The plan is to have full control over what apps/extensions are available – initially, we might populate it with only our known good apps. The Theia front-end can be configured (via `package.json` or an ENV variable) to use our registry endpoint instead of the default. This way, when the user opens the App Store view, it queries our registry. We also have the option to bundle some extensions pre-installed (built-ins) if certain apps are mandatory for all users.
- **Data Storage:** For the most part, the platform doesn’t need a central database – it’s a container. However, we will use Theia’s built-in storage for user preferences and state. Theia typically stores settings in JSON and can also retain UI layout between sessions. We will utilize these mechanisms to remember things like last open workspace or panel sizes. For any additional data (like saved workspace definitions, or user’s list of favorite apps for the dock), we can either use Theia’s preferences API or simply store in local storage (browser) / a config file on desktop. Given this is a client-side heavy app, no significant server component (besides the OpenVSX service) is planned initially.
- **Third-Party Libraries:** We will use FINOS FDC3 TypeScript definitions to ensure compliance (if available, e.g. `@finos/fdc3` npm package for types). We might also incorporate a message routing library if needed, but likely Theia’s own event emitters suffice. For the AI extension, integration with an external API (OpenAI, etc.) will be done carefully (maybe using Theia AI extension or a direct call with fetch in the extension). We need to be mindful of any licensing – Theia is EPL/Apache licensed, our code will follow compatible licensing (likely Apache 2.0 or similar).
- **Deployment and Build Process:** We plan to keep the build process aligned with Theia’s recommended approach:
  - Use **Yarn** workspaces and Lerna (Theia’s monorepo uses Lerna) to manage extensions and the overall application.
  - For the Electron app: use `yarn electron build` to produce installers for each OS: [theia-ide.org](https://theia-ide.org/docs/blueprint_documentation/#:~:text=The%20Theia%20IDE%20build%20uses,product%20as%20a%20desktop%20application). We’ll set up signing for Windows/macOS as needed (likely later, for distribution).
  - For the browser version: we can run Theia backend with `yarn start` (or a PM2 process in production). Optionally, containerize it with Docker for easy deployment on a server.
  - Continuous Integration: We’ll have CI scripts to build both versions and possibly publish the web version Docker image and the Electron artifacts.
  - We will also deploy our OpenVSX registry as a separate service (perhaps Dockerized as well). That requires periodic maintenance (to publish new app entries). In development, we might skip it and allow installing from the public OpenVSX, but production will use the private one.
- **Testing Strategy:** The plan will include a thorough testing approach: For the MVP we will keep tests minimal and lightweight, and rely on Theia's existing test suite, extending it where it makes sense without adding new dependencies. In future, we will consider the following:
  - **Unit Tests:** for the logic of context handling, intent routing, etc., using a framework like Mocha or Jest in the Theia environment.
  - **Integration Tests:** possibly using Theia’s built-in test support or Spectron (for Electron) to simulate user interactions: e.g., open two apps, broadcast a context, verify the other app received it.
  - **Manual Testing:** since UI/UX is crucial, we’ll have a period of manual testing to check that the workspace isolation feels correct, apps update as expected, and the UI remains responsive with multiple apps.
  - We also want to test both in Electron and pure browser to catch any differences (like `window.fdc3` injection might differ).

* **Future Architecture Considerations:** As the platform grows, we should keep in mind:
  - Possibly splitting out the DesktopAgent to a shared service if multiple windows are needed (e.g., an external process that all windows connect to, akin to OpenFin’s core).
  - Scaling the OpenVSX or moving to a more specialized app directory if needed for performance or richer metadata.
  - Adding a backend component for things like user login or data caching if we integrate with external data sources (for now, each app extension could directly fetch data from APIs, but a unified backend could mediate if needed later).

In summary, the plan is to **utilize Theia’s extension-based architecture** to transform the IDE into a context-driven workspace container. We carefully choose tech that aligns with Theia (TypeScript, VS Code extension format, Electron) to minimize risk. Each needed feature is an extension or configuration change, which keeps the design clean. The architecture favors an in-process event driven approach (since everything runs within the Theia container process or plugin process) for speed. We will document our extensions well so that others can build on this platform, following the open-source spirit.
